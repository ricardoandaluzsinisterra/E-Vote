================================================================================
                    E-VOTE FRONTEND ARCHITECTURE DOCUMENTATION
================================================================================

TABLE OF CONTENTS
=================
1. System Overview
2. Technology Stack
3. Project Structure
4. Application Entry Point
5. Routing Architecture
6. Authentication System
   6.1 Authentication Context
   6.2 Authentication Provider
   6.3 useAuth Hook
   6.4 JWT Token Handling
   6.5 LocalStorage Integration
7. Component Architecture
   7.1 Home Component
   7.2 Login Component
   7.3 Register Component
8. API Communication
   8.1 Backend Service
   8.2 API Endpoints
   8.3 Error Handling
9. Validation & Security
   9.1 Password Validation
   9.2 Form Validation
   9.3 Client-Side Security
10. Styling System
    10.1 CSS Architecture
    10.2 Design Tokens
    10.3 Dark Mode Support
    10.4 Responsive Design
11. TypeScript Configuration
12. Build & Development
13. State Management Patterns
14. Data Flow Diagram
15. Future Enhancements

================================================================================
1. SYSTEM OVERVIEW
================================================================================

The E-Vote frontend is a modern single-page application (SPA) built with
React 19 and TypeScript. It provides a secure, accessible interface for
electronic voting administration, including user authentication, voter email
management, and verification workflow.

KEY FEATURES:
- User authentication (login/register)
- JWT-based session management
- CSV file upload for voter emails
- Verification email distribution
- Responsive design with dark mode support
- Type-safe development with TypeScript
- Client-side form validation
- Accessible UI components (ARIA labels)

ARCHITECTURE PRINCIPLES:
- Component-based architecture
- Context API for global state
- Custom hooks for reusable logic
- Declarative routing with React Router
- Type safety with TypeScript
- Separation of concerns (UI, logic, services)
- Progressive enhancement

USER ROLES:
- Administrators: Upload voter lists, send verification emails
- Public Users: Access to registration and login

================================================================================
2. TECHNOLOGY STACK
================================================================================

CORE FRAMEWORK:
- React 19.1.1: UI library with latest features (concurrent rendering)
- React DOM 19.1.1: DOM-specific rendering methods
- TypeScript 5.9.3: Static type checking
- Vite 7.1.7: Build tool and dev server (fast HMR)

ROUTING:
- React Router DOM 7.9.6: Client-side routing
  * BrowserRouter for history management
  * Routes and Route components for declarative routing
  * useNavigate hook for programmatic navigation
  * Link component for navigation

STATE MANAGEMENT:
- React Context API: Global authentication state
- React Hooks (useState, useEffect, useContext): Local state
- Custom hooks (useAuth): Encapsulated logic

HTTP CLIENT:
- Fetch API: Native browser HTTP client
- No external dependencies (axios, etc.)

DEVELOPMENT TOOLS:
- ESLint 9.36.0: Code linting
- @vitejs/plugin-react 5.0.4: React plugin for Vite
- typescript-eslint 8.45.0: TypeScript-specific linting

TYPE DEFINITIONS:
- @types/react 19.1.16: React type definitions
- @types/react-dom 19.1.9: React DOM type definitions
- @types/node 24.10.1: Node.js type definitions

BUILD SYSTEM:
- Vite: Development server with HMR (Hot Module Replacement)
- TypeScript Compiler: Type checking and transpilation
- ES Modules: Modern module system

STYLING:
- CSS3: Custom properties (CSS variables)
- No CSS frameworks (Bootstrap, Tailwind, etc.)
- Native CSS with design system
- Media queries for dark mode

BROWSER APIS USED:
- localStorage: Token persistence
- fetch: HTTP requests
- atob: Base64 decoding (JWT)
- FormData: File uploads

================================================================================
3. PROJECT STRUCTURE
================================================================================

DIRECTORY TREE:

frontend/
├── public/                          # Static assets
│   └── vite.svg                     # Vite logo
│
├── src/                             # Source code
│   ├── assets/                      # Static assets (images, fonts)
│   │   └── react.svg                # React logo
│   │
│   ├── contexts/                    # React Context definitions
│   │   └── AuthContext.tsx          # Authentication context definition
│   │
│   ├── hooks/                       # Custom React hooks
│   │   └── useAuth.ts               # Hook to access auth context
│   │
│   ├── pages/                       # Page components (routes)
│   │   ├── Home.tsx                 # Home/dashboard page
│   │   ├── Login.tsx                # Login page
│   │   └── Register.tsx             # Registration page
│   │
│   ├── providers/                   # Context providers
│   │   └── AuthProvider.tsx         # Authentication provider implementation
│   │
│   ├── types/                       # TypeScript type definitions
│   │   └── auth.types.ts            # Authentication-related types
│   │
│   ├── utils/                       # Utility functions
│   │   ├── jwt.ts                   # JWT decoding utility
│   │   └── validators.ts            # Form validation functions
│   │
│   ├── App.css                      # App-specific styles
│   ├── App.tsx                      # Main App component with routing
│   ├── BackendService.ts            # API service (minimal implementation)
│   ├── declarations.d.ts            # TypeScript declaration file
│   ├── index.css                    # Global styles and design system
│   └── main.tsx                     # Application entry point
│
├── .devcontainer/                   # Dev container configuration
│   └── devcontainer.json            # VSCode dev container settings
│
├── Dockerfile                       # Container image definition
├── README.md                        # Project documentation
├── eslint.config.js                 # ESLint configuration
├── index.html                       # HTML entry point
├── package.json                     # NPM dependencies and scripts
├── package-lock.json                # Locked dependency versions
├── tsconfig.json                    # Root TypeScript config
├── tsconfig.app.json                # App-specific TypeScript config
├── tsconfig.node.json               # Node-specific TypeScript config
└── vite.config.ts                   # Vite configuration

NAMING CONVENTIONS:
- Components: PascalCase (Login.tsx, AuthProvider.tsx)
- Hooks: camelCase with 'use' prefix (useAuth.ts)
- Types: PascalCase with descriptive names (AuthContextType)
- Utilities: camelCase (validators.ts, jwt.ts)
- CSS classes: kebab-case (auth-card, form-field)

FILE ORGANIZATION PRINCIPLES:
- Colocation: Related files grouped together
- Feature-based: Pages, contexts, hooks separated
- Reusability: Utilities and types in shared folders
- Single responsibility: One component per file

================================================================================
4. APPLICATION ENTRY POINT
================================================================================

ENTRY FILE: src/main.tsx
--------------------------

The application bootstraps through a multi-layer provider wrapper:

LAYER 1: React StrictMode
- Enables additional development checks
- Detects potential problems in the application
- Activates deprecated lifecycle warnings
- Warns about legacy string ref usage

LAYER 2: BrowserRouter
- Provides routing context to entire application
- Uses HTML5 history API for clean URLs
- Enables client-side navigation without page reloads
- Manages browser history stack

LAYER 3: AuthProvider
- Provides authentication state globally
- Manages user session (token, user data)
- Handles login/logout/register operations
- Persists authentication to localStorage

LAYER 4: App Component
- Root component containing route definitions
- Renders different pages based on URL

RENDERING FLOW:

1. HTML Load (index.html):
   <!doctype html>
   <html lang="en">
     <head>
       <meta charset="UTF-8" />
       <meta name="viewport" content="width=device-width, initial-scale=1.0" />
       <title>frontend</title>
     </head>
     <body>
       <div id="root"></div>                  <!-- React mount point -->
       <script type="module" src="/src/main.tsx"></script>
     </body>
   </html>

2. JavaScript Execution (main.tsx):
   createRoot(document.getElementById("root")!)
     .render(
       <StrictMode>
         <BrowserRouter>
           <AuthProvider>
             <App />
           </AuthProvider>
         </BrowserRouter>
       </StrictMode>
     );

3. Component Tree:
   StrictMode
   └── BrowserRouter
       └── AuthProvider (manages auth state)
           └── App (routes)
               ├── Home (/)
               ├── Login (/login)
               └── Register (/register)

ROOT ELEMENT:
- ID: "root"
- Managed by React DOM
- All React components render inside this element

MODULE TYPE:
- Uses ES Modules (type="module" in script tag)
- Enables import/export syntax
- Allows tree-shaking and code splitting

DEVELOPMENT VS PRODUCTION:
- Development: Vite dev server with HMR
- Production: Static bundle with optimizations

================================================================================
5. ROUTING ARCHITECTURE
================================================================================

ROUTER: React Router DOM v7
----------------------------

The application uses declarative routing with three main routes:

ROUTE CONFIGURATION (App.tsx):

<Routes>
  <Route path="/" element={<Home />} />
  <Route path="/login" element={<Login />} />
  <Route path="/register" element={<Register />} />
</Routes>

ROUTES BREAKDOWN:

1. HOME ROUTE (/)
   Component: Home.tsx
   Purpose: Main dashboard/landing page
   Access: Public (shows login prompt if not authenticated)
   Features:
   - Administrator login button (when logged out)
   - CSV upload interface (when logged in)
   - Verification email sending (when logged in)
   - Logout functionality (when logged in)

2. LOGIN ROUTE (/login)
   Component: Login.tsx
   Purpose: User authentication
   Access: Public
   Features:
   - Email/password form
   - Error display
   - Links to home and register
   - Auto-redirect to home on success

3. REGISTER ROUTE (/register)
   Component: Register.tsx
   Purpose: New user account creation
   Access: Public
   Features:
   - Email/password/confirm-password form
   - Password strength validation
   - Password match validation
   - Success alert and redirect to login

NAVIGATION METHODS:

1. Declarative Navigation (Link):
   import { Link } from "react-router-dom";
   <Link to="/login">Sign in</Link>

2. Programmatic Navigation (useNavigate):
   const navigate = useNavigate();
   navigate("/");  // Redirect to home

3. Anchor Tags (for accessibility):
   <a href="/login">Administrator Login</a>

ROUTE MATCHING:
- Exact matching by default
- First matching route renders
- No nested routes (flat structure)

URL STRUCTURE:
- Base URL: http://localhost:5173
- Routes: /, /login, /register
- No query parameters used
- No URL parameters (no /user/:id)

BROWSER HISTORY:
- BrowserRouter uses pushState API
- Back/forward buttons work correctly
- Bookmarkable URLs
- No hash-based routing (#/)

PROTECTED ROUTES:
Currently no protected routes. Authentication is checked within components:
- Home shows different UI based on isAuthenticated
- Login/Register redirect after success
- No route-level guards (could be added)

FUTURE ENHANCEMENTS:
- Protected route wrapper component
- Route-level authentication guards
- 404 Not Found page
- Nested routes for dashboard sections
- Route-based code splitting

================================================================================
6. AUTHENTICATION SYSTEM
================================================================================

The authentication system uses React Context API for global state management,
providing a clean interface for login, registration, and session persistence.

6.1 AUTHENTICATION CONTEXT (contexts/AuthContext.tsx)
------------------------------------------------------

Defines the authentication context type and creates the context instance.

CONTEXT TYPE (AuthContextType):

interface AuthContextType {
  // STATE
  user: User | null;              // Current user data or null
  token: string | null;           // JWT access token or null
  isAuthenticated: boolean;       // Computed: true if user and token exist
  isLoading: boolean;             // Loading state during initialization

  // ACTIONS
  login: (email: string, password: string) => Promise<void>;
  register: (email: string, password: string) => Promise<void>;
  logout: () => void;
}

USER INTERFACE:

interface User {
  user_id: number;                // Unique user identifier
  email: string;                  // User email address
  is_verified: boolean;           // Email verification status
}

CONTEXT CREATION:

export const AuthContext = createContext<AuthContextType | undefined>(
  undefined
);

- Initial value: undefined (enforces use within provider)
- Type-safe access through custom hook
- No default values (prevents accidental use outside provider)

PURPOSE:
- Centralized authentication state
- Type-safe context access
- Enforces provider usage


6.2 AUTHENTICATION PROVIDER (providers/AuthProvider.tsx)
---------------------------------------------------------

Implements the authentication logic and provides context to children.

STATE MANAGEMENT:

const [token, setToken] = useState<string | null>(null);
const [user, setUser] = useState<User | null>(null);
const [isLoading, setIsLoading] = useState<boolean>(true);

COMPUTED VALUES:

const isAuthenticated = !!token && !!user;

- True only if both token AND user exist
- Double negation (!!) converts to boolean
- Prevents partial authentication state

INITIALIZATION (useEffect):

useEffect(() => {
  // Check localStorage for existing token
  const storedToken = localStorage.getItem("auth_token");

  if (storedToken) {
    // TODO: Validate token and fetch user data
    setToken(storedToken);
    setIsLoading(false);
  } else {
    setIsLoading(false);
  }
}, []);

Flow:
1. Component mounts
2. Check localStorage for "auth_token"
3. If exists: Set token (TODO: validate and fetch user)
4. Set isLoading to false
5. Empty dependency array: runs once on mount

CURRENT LIMITATION:
- Token is loaded but not validated
- User data not fetched from token
- Could load expired tokens
- Should decode JWT and verify expiration

LOGIN FUNCTION:

const login = async (email: string, password: string) => {
  // 1. Send login request
  const response = await fetch("http://localhost:8000/login", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ email, password }),
  });

  // 2. Handle email not verified error (403)
  if (response.status === 403) {
    const error = await response.json();
    throw new Error(error.detail);  // "Email not verified. Please verify..."
  }

  // 3. Handle other errors
  if (!response.ok) {
    throw new Error("Login failed");
  }

  // 4. Parse response
  const data: LoginResponse = await response.json();
  const token = data.access_token;

  // 5. Decode JWT to extract user info
  const decoded = decodeJWT(token);

  // 6. Persist token to localStorage
  localStorage.setItem("auth_token", token);

  // 7. Update state
  setToken(token);
  setUser({
    user_id: decoded.user_id,
    email: decoded.email,
    is_verified: true,  // Assumed true if login successful
  });
};

Error Handling:
- 403 Forbidden: Email not verified (specific message)
- 4xx/5xx: Generic "Login failed" message
- Network errors: Thrown by fetch (not caught)

Response Type (LoginResponse):
{
  access_token: string,    // JWT token
  token_type: string       // "bearer"
}

JWT Decoding:
- Extracts user_id and email from token payload
- No verification (should verify signature)
- Assumes token is valid

State Updates:
- Token stored in localStorage (persists across sessions)
- Token stored in state (for current session)
- User object created from JWT payload

REGISTER FUNCTION:

const register = async (email: string, password: string) => {
  try {
    // 1. Send registration request
    const response = await fetch("http://localhost:8000/register", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ email, password }),
    });

    // 2. Handle errors
    if (!response.ok) {
      throw new Error("Registration failed");
    }

    // 3. Parse response
    const data: RegisterResponse = await response.json();

    // 4. Log success (no automatic login)
    console.log("Registration successful:", data);
  } catch (error) {
    console.error("Registration error:", error);
    throw error;
  }
};

Response Type (RegisterResponse):
{
  user: User,
  verification_token: string
}

Current Behavior:
- Does not automatically log user in
- Returns to caller (page shows success alert)
- User must manually navigate to login page

TODO (noted in code):
- Auto-login after registration
- Or show verification email sent message

LOGOUT FUNCTION:

const logout = () => {
  localStorage.removeItem("auth_token");
  setToken(null);
  setUser(null);
};

Flow:
1. Remove token from localStorage
2. Clear token from state
3. Clear user from state
4. Component re-renders (isAuthenticated becomes false)

No API Call:
- JWT tokens are stateless
- No server-side session to invalidate
- Token remains valid until expiration
- Could add token blacklist in future

PROVIDER RENDERING:

const value: AuthContextType = {
  user,
  token,
  isAuthenticated,
  isLoading,
  login,
  register,
  logout,
};

return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;

- Creates context value object
- Wraps children with provider
- All children can access auth state


6.3 useAuth HOOK (hooks/useAuth.ts)
------------------------------------

Custom hook for convenient access to authentication context.

IMPLEMENTATION:

export function useAuth() {
  const context = useContext(AuthContext);

  if (context === undefined) {
    throw new Error("useAuth must be used within an AuthProvider");
  }

  return context;
}

FEATURES:

1. Type Safety:
   - Returns AuthContextType (never undefined)
   - TypeScript knows all properties exist

2. Error Handling:
   - Throws descriptive error if used outside provider
   - Prevents runtime errors from undefined context
   - Helps developers catch mistakes early

3. Convenience:
   - Single import instead of useContext + AuthContext
   - Shorter, more semantic syntax
   - Standard pattern in React community

USAGE:

// In component
const { user, isAuthenticated, login, logout } = useAuth();

// Type-safe access to all auth properties
if (isAuthenticated) {
  console.log("Logged in as:", user.email);
}

COMPARED TO DIRECT CONTEXT:

// Without custom hook (verbose)
const context = useContext(AuthContext);
if (!context) throw new Error("...");
const { user, login } = context;

// With custom hook (concise)
const { user, login } = useAuth();

ERROR PREVENTION:

// This will throw at runtime (caught during development)
function Component() {
  const auth = useAuth();  // ERROR: No AuthProvider above
  return <div>{auth.user?.email}</div>;
}

// Correct usage
function App() {
  return (
    <AuthProvider>
      <Component />  // useAuth() works here
    </AuthProvider>
  );
}


6.4 JWT TOKEN HANDLING (utils/jwt.ts)
--------------------------------------

Utility function for decoding JWT tokens client-side.

IMPLEMENTATION:

export function decodeJWT(token: string) {
  // 1. Split token into parts
  const base64Url = token.split(".")[1];  // Get payload (middle part)

  // 2. Convert Base64URL to Base64
  const base64 = base64Url.replace(/-/g, "+").replace(/_/g, "/");

  // 3. Decode Base64 to JSON string
  const jsonPayload = decodeURIComponent(
    atob(base64)
      .split("")
      .map((c) => "%" + ("00" + c.charCodeAt(0).toString(16)).slice(-2))
      .join("")
  );

  // 4. Parse JSON string to object
  return JSON.parse(jsonPayload);
}

JWT STRUCTURE:

A JWT token has three parts separated by dots:
  header.payload.signature

Example:
  eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.       <- Header
  eyJ1c2VyX2lkIjoxMjMsImVtYWlsIjoiQGV4YW1wbGUuY29tIn0. <- Payload
  SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c      <- Signature

DECODING STEPS:

1. Split by "." and get middle part (payload):
   "eyJ1c2VyX2lkIjoxMjMsImVtYWlsIjoiQGV4YW1wbGUuY29tIn0"

2. Base64URL to Base64:
   - Replace "-" with "+"
   - Replace "_" with "/"
   JWT uses Base64URL encoding (URL-safe variant)

3. Decode Base64 to UTF-8 string:
   - atob() converts Base64 to binary string
   - UTF-8 handling: Convert each char to %XX hex
   - decodeURIComponent() converts %XX to UTF-8

   This complex step ensures proper UTF-8 handling for international
   characters in email addresses or other fields.

4. Parse JSON to object:
   {
     "user_id": 123,
     "email": "user@example.com",
     "iat": 1699234567,
     "exp": 1699320967
   }

SECURITY NOTES:

WARNING: This function only DECODES the token, it does NOT verify it!

- Does not check signature
- Does not verify expiration
- Does not validate issuer
- Anyone can decode JWT (it's not encrypted)

Why it's safe:
- Token is already verified by backend on login
- This is just for extracting user info
- Not used for authorization decisions
- Only used to populate UI with user data

What could go wrong:
- Expired token not detected
- Tampered token not detected
- Invalid token format causes parse error

BETTER APPROACH (future):
- Use a JWT library (jsonwebtoken, jose)
- Verify signature client-side (requires public key)
- Check expiration before using
- Handle decode errors gracefully


6.5 LOCALSTORAGE INTEGRATION
-----------------------------

Token persistence strategy using browser localStorage.

STORAGE KEY: "auth_token"

OPERATIONS:

1. Save Token (on login):
   localStorage.setItem("auth_token", token);

2. Load Token (on app init):
   const storedToken = localStorage.getItem("auth_token");

3. Remove Token (on logout):
   localStorage.removeItem("auth_token");

CHARACTERISTICS:

Storage Type: localStorage (not sessionStorage)
- Persists across browser sessions
- Survives tab close and browser restart
- Shared across all tabs of same origin
- Cleared only on explicit logout or manual deletion

Domain Scope: Origin-based
- Accessible only from same origin (protocol + domain + port)
- Not accessible from other domains
- Not sent automatically with requests (unlike cookies)

Size Limit:
- 5-10 MB depending on browser
- JWT token is typically < 1 KB
- More than sufficient for single token

SECURITY CONSIDERATIONS:

XSS Vulnerability:
- localStorage is accessible to JavaScript
- XSS attacks can steal token
- Mitigation: Sanitize all user input, use CSP

CSRF Protection:
- Token not sent automatically (like cookies)
- Must be explicitly added to requests
- Protects against CSRF attacks

Token Expiration:
- Token stored even after expiration
- Not checked on load (TODO)
- Should verify expiration on app init

ALTERNATIVE APPROACHES:

1. sessionStorage:
   - Clears on tab close
   - Better security (shorter lifetime)
   - Worse UX (must login every tab)

2. httpOnly Cookies:
   - Not accessible to JavaScript (XSS-proof)
   - Sent automatically with requests
   - Vulnerable to CSRF (need CSRF tokens)
   - Can't decode client-side for user info

3. Secure + httpOnly Cookies:
   - Best security
   - Requires HTTPS
   - Backend must handle cookie setting
   - Current backend doesn't support

CURRENT CHOICE: localStorage
- Simple implementation
- Good UX (persistent sessions)
- Standard for JWT SPAs
- Trade-off: XSS vulnerability

BEST PRACTICES:

1. Always use HTTPS in production
2. Implement Content Security Policy (CSP)
3. Validate/sanitize all user input
4. Check token expiration on load
5. Implement token refresh before expiration
6. Consider secure cookies for production

TOKEN REFRESH STRATEGY (not implemented):

// Check expiration on load
if (storedToken) {
  const decoded = decodeJWT(storedToken);
  const now = Math.floor(Date.now() / 1000);

  if (decoded.exp < now) {
    // Token expired, remove it
    localStorage.removeItem("auth_token");
  } else if (decoded.exp - now < 3600) {
    // Token expires in < 1 hour, refresh it
    refreshToken();
  } else {
    // Token valid, use it
    setToken(storedToken);
  }
}

================================================================================
7. COMPONENT ARCHITECTURE
================================================================================

7.1 HOME COMPONENT (pages/Home.tsx)
------------------------------------

The home page serves dual purposes:
1. Landing page with login prompt (logged out)
2. Admin dashboard for voter management (logged in)

COMPONENT STATE:

const [selectedFile, setSelectedFile] = useState<File | null>(null);
const [uploadStatus, setUploadStatus] = useState<string>("");
const [isUploaded, setIsUploaded] = useState<boolean>(false);
const [isProcessing, setIsProcessing] = useState<boolean>(false);

State Breakdown:
- selectedFile: CSV file selected by user (File object or null)
- uploadStatus: Status message displayed to user
- isUploaded: True after successful upload (enables verification button)
- isProcessing: True during API calls (disables buttons)

AUTH INTEGRATION:

const { user, isAuthenticated, logout } = useAuth();

CONDITIONAL RENDERING:

Two completely different UIs based on authentication state:

if (!isAuthenticated || !user) {
  return <LandingPageUI />;    // Administrator Login button
}

return <AdminDashboardUI />;   // CSV upload and verification

LOGGED OUT VIEW:

<main className="app-container">
  <section className="auth-card">
    <h1 className="auth-header">E‑Vote</h1>
    <p className="muted">Secure, auditable online voting</p>

    <a href="/login" className="btn primary">
      Administrator Login
    </a>
  </section>
</main>

Features:
- Application branding
- Clear call-to-action
- Simple, focused interface
- Accessible (semantic HTML)

LOGGED IN VIEW - CSV UPLOAD:

FILE SELECTION HANDLER:

const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
  const file = event.target.files?.[0];

  if (file && file.type === "text/csv") {
    setSelectedFile(file);
    setUploadStatus("");
  } else {
    setUploadStatus("Please select a valid CSV file");
    setSelectedFile(null);
  }
};

Validation:
- Checks file exists (files?.[0] optional chaining)
- Validates MIME type (text/csv)
- Clears previous status messages
- Resets state if invalid

MIME Type Check:
- Relies on browser-provided MIME type
- Can be spoofed (file extension != MIME type)
- Backend should also validate

FILE UPLOAD HANDLER:

const handleUpload = async () => {
  if (!selectedFile || !user) return;

  setIsProcessing(true);
  setUploadStatus("Uploading...");

  const formData = new FormData();
  formData.append("file", selectedFile);
  formData.append("user_id", user.id || user.email);

  try {
    const response = await fetch("http://localhost:8000/upload-emails", {
      method: "POST",
      body: formData,
    });

    if (response.ok) {
      const data = await response.json();
      setUploadStatus(`Successfully uploaded ${data.count} emails`);
      setIsUploaded(true);
    } else {
      const error = await response.json();
      setUploadStatus(`Error: ${error.detail || "Upload failed"}`);
    }
  } catch (error) {
    setUploadStatus("Error: Could not connect to server");
  } finally {
    setIsProcessing(false);
  }
};

Key Points:
1. Guard clause: Early return if no file or user
2. FormData: Proper multipart/form-data encoding
3. user.id fallback: Uses email if id not available (id property doesn't exist on User type)
4. Success case: Shows count of uploaded emails
5. Error handling: Different messages for HTTP errors vs network errors
6. Finally block: Always reset isProcessing

FormData API:
- Automatically sets Content-Type: multipart/form-data
- No need to manually set header
- Sends file as binary data

VERIFICATION EMAIL HANDLER:

const handleSendVerifications = async () => {
  if (!user) return;

  setIsProcessing(true);
  setUploadStatus("Sending verification emails...");

  try {
    const response = await fetch("http://localhost:8000/send-verifications", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ user_id: user.id || user.email }),
    });

    if (response.ok) {
      const data = await response.json();
      setUploadStatus(`Sent ${data.sent} verification emails`);
    } else {
      const error = await response.json();
      setUploadStatus(`Error: ${error.detail || "Failed to send emails"}`);
    }
  } catch (error) {
    setUploadStatus("Error: Could not connect to server");
  } finally {
    setIsProcessing(false);
  }
};

Similar structure to upload, but:
- JSON body instead of FormData
- Different endpoint
- Different success message

UI STRUCTURE:

<main className="app-container">
  <section className="auth-card">
    <h1>Upload Voter Emails</h1>
    <p>Signed in as {user.email}</p>

    {/* File Input */}
    <input type="file" accept=".csv" onChange={handleFileChange} />

    {/* Upload Button */}
    <button
      onClick={handleUpload}
      disabled={!selectedFile || isProcessing}
    >
      {isProcessing ? "Processing..." : "Upload Emails File"}
    </button>

    {/* Status Message */}
    {uploadStatus && <p>{uploadStatus}</p>}

    {/* Verification Button (conditional) */}
    {isUploaded && (
      <button onClick={handleSendVerifications} disabled={isProcessing}>
        Send Verification Emails
      </button>
    )}

    {/* Logout Button */}
    <button onClick={logout}>Logout</button>
  </section>
</main>

Button States:
- Upload: Disabled if no file selected or processing
- Verification: Only shown after successful upload, disabled if processing
- Loading text: Button text changes during processing

FILE INPUT:
- accept=".csv": Browser file picker shows CSV files
- Not foolproof: User can select "All Files" and choose non-CSV
- onChange: Triggers validation on file selection

ACCESSIBILITY:
- Semantic HTML (main, section, h1)
- Labels for inputs (htmlFor)
- Button disabled states
- Loading indicators (button text change)

USER EXPERIENCE:
1. Select CSV file
2. Click "Upload Emails File"
3. See "Uploading..." on button
4. See "Successfully uploaded N emails"
5. "Send Verification Emails" button appears
6. Click to send verification emails
7. See "Sent N verification emails"


7.2 LOGIN COMPONENT (pages/Login.tsx)
--------------------------------------

Handles user authentication with email and password.

COMPONENT STATE:

const [email, setEmail] = useState("");
const [password, setPassword] = useState("");
const [error, setError] = useState("");
const [isLoading, setIsLoading] = useState(false);

State Management:
- Controlled form inputs (React manages input values)
- Error message for failed attempts
- Loading state for async operation

HOOKS USED:

const { login } = useAuth();
const navigate = useNavigate();

- useAuth: Access login function from context
- useNavigate: Programmatic navigation after success

FORM SUBMISSION HANDLER:

const handleSubmit = async (e: React.FormEvent) => {
  e.preventDefault();              // Prevent page reload
  setError("");                    // Clear previous errors
  setIsLoading(true);              // Show loading state

  try {
    await login(email, password);  // Call AuthProvider login
    navigate("/");                 // Redirect to home on success
  } catch (err) {
    if (err instanceof Error) {
      setError(err.message);       // Show error message
    } else {
      setError("Login failed. Please try again.");
    }
  } finally {
    setIsLoading(false);           // Always reset loading
  }
};

Flow:
1. Prevent default form submission
2. Clear any previous error
3. Set loading state
4. Call login function
5. On success: Navigate to home
6. On error: Display error message
7. Always: Reset loading state

Error Types Caught:
- Error objects: Display message from backend (e.g., "Email not verified")
- Other throws: Generic "Login failed" message
- Network errors: Handled by login function

FORM STRUCTURE:

<form onSubmit={handleSubmit} aria-describedby={error ? "error-message" : undefined}>
  <div className="form-field">
    <label htmlFor="email">Email</label>
    <input
      type="email"
      id="email"
      value={email}
      onChange={(e) => setEmail(e.target.value)}
      required
      aria-required="true"
      autoComplete="email"
      placeholder="you@example.com"
    />
  </div>

  <div className="form-field">
    <label htmlFor="password">Password</label>
    <input
      type="password"
      id="password"
      value={password}
      onChange={(e) => setPassword(e.target.value)}
      required
      aria-required="true"
      autoComplete="current-password"
      placeholder="Your password"
    />
  </div>

  <button type="submit" disabled={isLoading}>
    {isLoading ? "Logging in..." : "Sign in"}
  </button>
</form>

ACCESSIBILITY FEATURES:

1. Semantic HTML:
   - <form> element (not div with onClick)
   - <label> elements with htmlFor
   - Proper heading hierarchy

2. ARIA Attributes:
   - aria-labelledby: Associates heading with section
   - aria-required: Indicates required fields
   - aria-describedby: Links form to error message
   - role="alert": Error is announced to screen readers
   - aria-live="assertive": Error interrupts screen reader

3. Form Attributes:
   - required: HTML5 validation
   - type="email": Browser validation
   - autoComplete: Browser autofill (privacy + UX)

4. Focus Management:
   - Browser focuses first input by default
   - Tab navigation works correctly

ERROR DISPLAY:

{error && (
  <div role="alert" aria-live="assertive" className="error">
    {error}
  </div>
)}

- Conditional rendering (only if error exists)
- ARIA role="alert" announces to screen readers
- aria-live="assertive" interrupts current reading
- CSS class for styling (red text)

NAVIGATION LINKS:

<div className="auth-footer muted">
  <Link to="/">Home</Link>
  <Link to="/register">Create account</Link>
</div>

- React Router Link components
- Client-side navigation (no page reload)
- Semantic links (not buttons)
- Footer placement (visual hierarchy)

BUTTON LOADING STATE:

<button type="submit" disabled={isLoading}>
  {isLoading ? "Logging in..." : "Sign in"}
</button>

Features:
- Disabled during processing (prevents double submission)
- Text changes to show progress
- Visual feedback (button appears disabled in CSS)

UX FLOW:
1. User enters email and password
2. Clicks "Sign in"
3. Button shows "Logging in..." and becomes disabled
4. Success: Redirected to home
5. Error: Error message appears above form
6. User can try again


7.3 REGISTER COMPONENT (pages/Register.tsx)
--------------------------------------------

Handles new user account creation with password validation.

COMPONENT STATE:

const [email, setEmail] = useState("");
const [password, setPassword] = useState("");
const [confirmPassword, setConfirmPassword] = useState("");
const [error, setError] = useState("");
const [isLoading, setIsLoading] = useState(false);

Additional state compared to Login:
- confirmPassword: Password confirmation field
- More complex validation logic

HOOKS USED:

const { register } = useAuth();
const navigate = useNavigate();

COMPUTED VALUES:

const passwordsMatch = password === confirmPassword;
const passwordIsValid = isPasswordSecure(password);
const canSubmit = email && passwordIsValid && passwordsMatch;

Real-time validation:
- passwordsMatch: Checks if both passwords are identical
- passwordIsValid: Calls validator function (8+ chars, upper, lower, digit, special)
- canSubmit: All conditions must be true to enable submit

FORM SUBMISSION HANDLER:

const handleSubmit = async (e: React.FormEvent) => {
  e.preventDefault();
  setError("");

  // Client-side validation
  if (!passwordIsValid) {
    setError("Password does not meet security requirements.");
    return;
  }

  if (!passwordsMatch) {
    setError("Passwords don't match.");
    return;
  }

  setIsLoading(true);

  try {
    await register(email, password);
    alert("Registration successful! Please check your email to verify your account.");
    navigate("/login");
  } catch (err) {
    if (err instanceof Error) {
      setError(err.message);
    } else {
      setError("Registration failed. Please try again.");
    }
  } finally {
    setIsLoading(false);
  }
};

Validation Flow:
1. Check password meets security requirements
2. Check passwords match
3. Early return with error if validation fails
4. Proceed with API call if all valid

Success Flow:
- Shows browser alert (not ideal UX, but simple)
- Navigates to login page
- User must login separately (not auto-logged in)

Alert vs Toast:
- alert(): Blocks execution, simple but intrusive
- Better: Toast notification library
- Best: Inline success message with auto-redirect

FORM STRUCTURE:

<form onSubmit={handleSubmit}>
  {/* Email Field */}
  <div className="form-field">
    <label htmlFor="email">Email</label>
    <input
      id="email"
      type="email"
      value={email}
      onChange={(e) => setEmail(e.target.value)}
      required
      aria-required="true"
      autoComplete="email"
      placeholder="you@example.com"
    />
  </div>

  {/* Password Field with Help Text */}
  <div className="form-field">
    <label htmlFor="password">Password</label>
    <input
      id="password"
      type="password"
      value={password}
      onChange={(e) => setPassword(e.target.value)}
      required
      aria-describedby="passwordHelp"
      autoComplete="new-password"
      placeholder="At least 8 characters"
    />
    <small id="passwordHelp" className="muted">
      Password must be 8+ characters, include upper & lower letters,
      a digit and a special character.
    </small>
  </div>

  {/* Confirm Password Field with Match Validation */}
  <div className="form-field">
    <label htmlFor="confirmPassword">Confirm password</label>
    <input
      id="confirmPassword"
      type="password"
      value={confirmPassword}
      onChange={(e) => setConfirmPassword(e.target.value)}
      required
      aria-required="true"
      autoComplete="new-password"
      placeholder="Repeat password"
    />
    {!passwordsMatch && confirmPassword.length > 0 && (
      <p className="error">Passwords do not match.</p>
    )}
  </div>

  {/* Submit Button */}
  <button
    type="submit"
    disabled={!canSubmit || isLoading}
  >
    {isLoading ? "Creating..." : "Create account"}
  </button>
</form>

PASSWORD HELP TEXT:

<small id="passwordHelp" className="muted">
  Password must be 8+ characters, include upper & lower letters,
  a digit and a special character.
</small>

Features:
- aria-describedby links input to help text
- Screen readers announce requirements when input focused
- Visible to all users (not just screen reader)
- Clear, specific requirements

REAL-TIME PASSWORD MATCH VALIDATION:

{!passwordsMatch && confirmPassword.length > 0 && (
  <p className="error">Passwords do not match.</p>
)}

Conditional display:
- Only shows if passwords don't match
- AND confirm password has content (avoids showing on empty)
- Immediate feedback (updates on every keystroke)
- Helps user correct mistake before submission

BUTTON DISABLED LOGIC:

disabled={!canSubmit || isLoading}

Button disabled if:
- Email is empty
- Password doesn't meet requirements
- Passwords don't match
- OR form is submitting

User feedback:
- Disabled state styled in CSS (opacity, no hover)
- Prevents invalid submission
- Clear visual indication

PASSWORD VALIDATION (isPasswordSecure):
Imported from utils/validators.ts (detailed in section 9.1)

NAVIGATION LINKS:

<div className="auth-footer muted">
  <Link to="/">Home</Link>
  <Link to="/login">Sign in</Link>
</div>

Alternative actions:
- Return to home
- Go to login (if already have account)

UX IMPROVEMENTS:

Current:
- Browser alert on success
- Manual navigation to login

Better:
- Inline success message
- Auto-redirect after 3 seconds
- Show verification email sent message

Best:
- Toast notification
- Auto-login after registration
- Email verification in background

================================================================================
8. API COMMUNICATION
================================================================================

8.1 BACKEND SERVICE (BackendService.ts)
----------------------------------------

Minimal service class for API configuration (currently underutilized).

IMPLEMENTATION:

class BackendService {
  private baseURL: string;

  constructor(baseURL: string) {
    this.baseURL = import.meta.env.VITE_API_URL || baseURL;
  }

  // Your methods here...
}

export default new BackendService("http://localhost:8000");

FEATURES:

Environment Variable Support:
- Checks import.meta.env.VITE_API_URL
- Falls back to constructor parameter
- Allows different URLs per environment

Vite Environment Variables:
- Prefix: VITE_ (required for client exposure)
- .env file: VITE_API_URL=https://api.production.com
- import.meta.env: Vite-specific (not process.env)

Singleton Pattern:
- Single instance exported
- Shared across entire application
- Could be instantiated differently per environment

CURRENT USAGE:

The BackendService class is defined but NOT USED in the codebase.
All API calls use fetch() directly with hardcoded URLs.

Example (from AuthProvider.tsx):
  await fetch("http://localhost:8000/login", {...})

Should be:
  await BackendService.login(email, password)

WHY IT'S NOT USED:

Likely reasons:
1. Early development (not refactored yet)
2. Simple requirements (few endpoints)
3. Placeholder for future expansion

RECOMMENDED REFACTORING:

class BackendService {
  private baseURL: string;

  constructor(baseURL: string) {
    this.baseURL = import.meta.env.VITE_API_URL || baseURL;
  }

  async login(email: string, password: string) {
    const response = await fetch(`${this.baseURL}/login`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ email, password }),
    });

    if (!response.ok) {
      throw new Error("Login failed");
    }

    return response.json();
  }

  async register(email: string, password: string) {
    const response = await fetch(`${this.baseURL}/register`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ email, password }),
    });

    if (!response.ok) {
      throw new Error("Registration failed");
    }

    return response.json();
  }

  async uploadEmails(file: File, userId: string) {
    const formData = new FormData();
    formData.append("file", file);
    formData.append("user_id", userId);

    const response = await fetch(`${this.baseURL}/upload-emails`, {
      method: "POST",
      body: formData,
    });

    if (!response.ok) {
      throw new Error("Upload failed");
    }

    return response.json();
  }

  async sendVerifications(userId: string) {
    const response = await fetch(`${this.baseURL}/send-verifications`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ user_id: userId }),
    });

    if (!response.ok) {
      throw new Error("Failed to send verifications");
    }

    return response.json();
  }
}

export default new BackendService("http://localhost:8000");

BENEFITS OF REFACTORING:

1. Centralized Configuration:
   - Single place to change base URL
   - Environment-specific URLs
   - Easy to add authentication headers

2. Reusability:
   - DRY principle (Don't Repeat Yourself)
   - Consistent error handling
   - Easier testing (mock service)

3. Type Safety:
   - Typed request/response
   - Compile-time checking
   - Better IDE autocomplete

4. Maintainability:
   - API changes in one place
   - Easier to add interceptors
   - Centralized logging


8.2 API ENDPOINTS
-----------------

All API calls currently use hardcoded URLs with fetch().

AUTHENTICATION ENDPOINTS:

1. POST /login
   URL: http://localhost:8000/login
   Headers: Content-Type: application/json
   Body: {
     email: string,
     password: string
   }
   Response: {
     access_token: string,
     token_type: "bearer"
   }
   Errors:
   - 401: Invalid credentials
   - 403: Email not verified

2. POST /register
   URL: http://localhost:8000/register
   Headers: Content-Type: application/json
   Body: {
     email: string,
     password: string
   }
   Response: {
     user: {
       user_id: number,
       email: string,
       is_verified: boolean
     },
     verification_token: string
   }
   Errors:
   - 400: Weak password
   - 409: Email already exists

VOTER MANAGEMENT ENDPOINTS:

3. POST /upload-emails
   URL: http://localhost:8000/upload-emails
   Headers: (auto-set by FormData)
   Body: FormData {
     file: File (CSV),
     user_id: string
   }
   Response: {
     count: number  // Number of emails uploaded
   }
   Errors:
   - 400: Invalid file format
   - 413: File too large

4. POST /send-verifications
   URL: http://localhost:8000/send-verifications
   Headers: Content-Type: application/json
   Body: {
     user_id: string
   }
   Response: {
     sent: number  // Number of emails sent
   }
   Errors:
   - 404: No emails to send
   - 500: Email service error

ENDPOINT PATTERNS:

Base URL: http://localhost:8000
- Should be configurable via environment variable
- Currently hardcoded in multiple places

Request Format:
- JSON for most endpoints (Content-Type: application/json)
- FormData for file upload (auto-set Content-Type: multipart/form-data)

Response Format:
- Always JSON
- Consistent error structure: { detail: string }

HTTP Methods:
- POST for all mutations (no GET, PUT, DELETE)
- RESTful endpoints would use:
  * GET /users/:id
  * PUT /users/:id
  * DELETE /users/:id

Authentication:
- JWT token returned on login
- Should be sent in Authorization header for protected routes
- Currently no protected routes in frontend


8.3 ERROR HANDLING
------------------

Error handling strategy across the application.

FETCH ERROR TYPES:

1. Network Errors:
   - Thrown by fetch() before reaching try/catch
   - Examples: DNS failure, offline, CORS
   - Caught in catch block
   - Generic message: "Could not connect to server"

2. HTTP Errors:
   - fetch() doesn't throw on 4xx/5xx
   - Must check response.ok (status 200-299)
   - Parse error response body
   - Show specific error message

3. Parse Errors:
   - JSON parsing can throw
   - Invalid response format
   - Caught in catch block

ERROR HANDLING PATTERN:

try {
  const response = await fetch(url, options);

  // Check HTTP status
  if (!response.ok) {
    // Try to parse error details
    const error = await response.json();
    throw new Error(error.detail || "Operation failed");
  }

  // Parse success response
  const data = await response.json();
  return data;

} catch (error) {
  // Handle network errors or thrown errors
  if (error instanceof Error) {
    setError(error.message);
  } else {
    setError("An unexpected error occurred");
  }
}

SPECIFIC ERROR HANDLING:

Login (AuthProvider.tsx):

// Special case for 403 (email not verified)
if (response.status === 403) {
  const error = await response.json();
  throw new Error(error.detail);  // "Email not verified. Please verify..."
}

Why special case:
- 403 has specific meaning (email not verified)
- Different from generic "Login failed"
- Gives user actionable information

ERROR MESSAGE DISPLAY:

Component Level:
{error && (
  <div role="alert" aria-live="assertive" className="error">
    {error}
  </div>
)}

Features:
- Conditional rendering
- ARIA attributes for accessibility
- CSS styling (red text)
- Above form (user sees immediately)

Error State Reset:
- Cleared on new submission (setError(""))
- Prevents stale error messages
- Clear button could also clear error

LOADING STATES:

Pattern across all async operations:
1. Set isLoading to true
2. Disable submit button
3. Change button text ("Loading...")
4. Perform operation
5. Set isLoading to false (in finally block)

Benefits:
- Prevents double submission
- Visual feedback
- Always resets (even on error)

FUTURE IMPROVEMENTS:

1. Global Error Handler:
   - Catch all unhandled errors
   - Display toast notifications
   - Log errors to monitoring service

2. Retry Logic:
   - Automatically retry failed requests
   - Exponential backoff
   - Max retry limit

3. Offline Detection:
   - Check navigator.onLine
   - Show offline banner
   - Queue requests when offline

4. Validation Errors:
   - Field-specific errors (not just form-level)
   - Highlight invalid fields
   - Show validation messages below inputs

5. Error Logging:
   - Send errors to backend
   - Track error frequency
   - Monitor user impact

================================================================================
9. VALIDATION & SECURITY
================================================================================

9.1 PASSWORD VALIDATION (utils/validators.ts)
----------------------------------------------

Client-side password strength validation.

IMPLEMENTATION:

export function isPasswordSecure(password: string): boolean {
  const minLength = 8;
  const uppercaseRegex = /[A-Z]/;
  const lowercaseRegex = /[a-z]/;
  const digitRegex = /\d/;
  const specialCharRegex = /[!@#$%^&*()_\-+=]/;

  return (
    password.length >= minLength &&
    uppercaseRegex.test(password) &&
    lowercaseRegex.test(password) &&
    digitRegex.test(password) &&
    specialCharRegex.test(password)
  );
}

REQUIREMENTS:

1. Minimum Length: 8 characters
   - Industry standard minimum
   - NIST recommends 8-64 characters
   - Balances security and usability

2. Uppercase Letter: [A-Z]
   - At least one capital letter
   - Increases character space (26 additional chars)

3. Lowercase Letter: [a-z]
   - At least one lowercase letter
   - Case sensitivity increases complexity

4. Digit: \d (equivalent to [0-9])
   - At least one number
   - Adds 10 additional characters to space

5. Special Character: [!@#$%^&*()_\-+=]
   - Limited set of special characters
   - Should expand to include more (see improvements)

CHARACTER SPACE CALCULATION:

If all requirements met:
- Lowercase: 26 characters
- Uppercase: 26 characters
- Digits: 10 characters
- Special: 11 characters (from regex)
- Total: 73 characters

Entropy with 8-char password:
- log2(73^8) ≈ 49.3 bits
- Decent but not excellent

REGEX BREAKDOWN:

/[A-Z]/:
- Character class for uppercase
- Matches A through Z
- Global flag not needed (test() only checks if exists)

/[a-z]/:
- Character class for lowercase
- Matches a through z

/\d/:
- Shorthand for [0-9]
- Matches any digit

/[!@#$%^&*()_\-+=]/:
- Character class for special characters
- Hyphen escaped: \-
- Limited set (should include more)

VALIDATION FLOW:

1. Check length >= 8
2. Test for uppercase (short-circuits if false)
3. Test for lowercase
4. Test for digit
5. Test for special character
6. Return true only if ALL conditions met

Short-Circuit Evaluation:
- && operator stops at first false
- Efficient (doesn't check all if first fails)
- Order matters for performance

USAGE IN REGISTER COMPONENT:

const passwordIsValid = isPasswordSecure(password);
const canSubmit = email && passwordIsValid && passwordsMatch;

Real-time validation:
- Runs on every keystroke (password state change)
- Updates canSubmit computed value
- Enables/disables submit button

USER FEEDBACK:

Help text shown before validation:
<small id="passwordHelp">
  Password must be 8+ characters, include upper & lower letters,
  a digit and a special character.
</small>

Error shown on submit if invalid:
if (!passwordIsValid) {
  setError("Password does not meet security requirements.");
  return;
}

LIMITATIONS:

1. Limited Special Characters:
   - Only 11 characters: !@#$%^&*()_-+=
   - Should include: <>?/{}[]|~`.:;"'
   - Many valid special chars excluded

2. No Maximum Length:
   - Should enforce reasonable max (e.g., 128)
   - Prevent DOS attacks (bcrypt has 72-char limit)

3. No Common Password Check:
   - Doesn't check against common passwords
   - "Password1!" meets requirements but weak
   - Should use password blacklist

4. No Entropy Calculation:
   - Backend has entropy-based validation
   - Frontend only checks character types
   - Inconsistent with backend

5. Predictable Requirements:
   - Attackers know requirements
   - Can optimize dictionary attacks
   - Pattern: Capital + lowercase + number + special

IMPROVEMENTS:

1. Expand Special Characters:
   const specialCharRegex = /[!@#$%^&*()_\-+=<>?/{}[\]|~`.:;"'\\]/;

2. Add Maximum Length:
   const maxLength = 128;
   return (
     password.length >= minLength &&
     password.length <= maxLength &&
     // ... other checks
   );

3. Check Common Passwords:
   const commonPasswords = ["Password1!", "Welcome123!", ...];
   if (commonPasswords.includes(password)) {
     return false;
   }

4. Entropy-Based Validation (match backend):
   function calculateEntropy(password: string): number {
     let charSpace = 0;
     if (/[a-z]/.test(password)) charSpace += 26;
     if (/[A-Z]/.test(password)) charSpace += 26;
     if (/\d/.test(password)) charSpace += 10;
     if (/[^a-zA-Z0-9]/.test(password)) charSpace += 32;
     return password.length * Math.log2(charSpace);
   }

   export function isPasswordSecure(password: string): boolean {
     return calculateEntropy(password) >= 50;  // Match backend threshold
   }

5. Visual Strength Meter:
   - Show password strength (Weak, Medium, Strong)
   - Color-coded (red, yellow, green)
   - Help user create stronger password

BACKEND VALIDATION:

Backend also validates password (auth_service/auth/password_utils.py):
- Entropy-based: >= 50 bits required
- More sophisticated than frontend
- Frontend validation is UX enhancement
- Backend validation is security requirement

SECURITY NOTE:

Client-side validation is NOT a security measure:
- Can be bypassed (disable JavaScript)
- Modify request in browser DevTools
- Use curl or Postman directly

Purpose of client-side validation:
- User experience (immediate feedback)
- Reduce server load (fewer invalid requests)
- Guide users to create secure passwords

Backend MUST validate:
- Never trust client input
- Enforce same or stricter rules
- Rate limit registration attempts


9.2 FORM VALIDATION
-------------------

HTML5 and React form validation patterns.

HTML5 VALIDATION:

Built-in browser validation:
<input
  type="email"           // Validates email format
  required               // Field must be filled
  minLength={8}          // Minimum 8 characters
  maxLength={128}        // Maximum 128 characters
/>

Browser behavior:
- Shows validation messages automatically
- Prevents form submission if invalid
- Customizable with :invalid CSS
- Works without JavaScript

EMAIL VALIDATION:

type="email" validates format:
- Must contain @
- Must have domain
- Allows: user@example.com
- Rejects: user@, @example.com, user

Limitations:
- Basic validation only
- Doesn't verify email exists
- Doesn't check for typos (gmail.co instead of gmail.com)
- Allows invalid but syntactically correct addresses

Better validation:
- Use email validation library (validator.js)
- Check for common typos (did you mean gmail.com?)
- Send verification email (only way to truly verify)

REQUIRED FIELDS:

<input required aria-required="true" />

HTML5 required:
- Browser validation
- Native error messages
- Styling with :required CSS

ARIA required:
- Accessibility
- Screen readers announce "required"
- Redundant with HTML5 but ensures compatibility

CONTROLLED INPUTS:

React pattern for form control:
const [email, setEmail] = useState("");
<input value={email} onChange={(e) => setEmail(e.target.value)} />

Benefits:
- React state is source of truth
- Can validate on every keystroke
- Can transform input (uppercase, trim, etc.)
- Can compute derived values

REAL-TIME VALIDATION:

Password match validation:
{!passwordsMatch && confirmPassword.length > 0 && (
  <p className="error">Passwords do not match.</p>
)}

When to show errors:
- On blur (when user leaves field)
- On change (as user types)
- On submit (when form submitted)

Best practice:
- Show success on blur/change (green checkmark)
- Show errors only on blur or submit (not as typing)
- Exception: Password match (show immediately)

CUSTOM VALIDATION:

isPasswordSecure() function:
- Called on every state change
- Returns boolean
- Used to disable submit button

const passwordIsValid = isPasswordSecure(password);
<button disabled={!passwordIsValid}>Submit</button>

SUBMIT VALIDATION:

Validate again on submit (even if button enabled):
const handleSubmit = async (e: React.FormEvent) => {
  e.preventDefault();

  if (!passwordIsValid) {
    setError("Password does not meet security requirements.");
    return;
  }

  if (!passwordsMatch) {
    setError("Passwords don't match.");
    return;
  }

  // Proceed with submission
};

Why validate again:
- User might bypass disabled button (DevTools)
- State might be stale
- Defense in depth

FORM SUBMISSION PREVENTION:

e.preventDefault():
- Stops default form submission
- Prevents page reload
- Allows custom handling (fetch API)

Without preventDefault():
- Browser submits form
- Page reloads
- Loses React state
- Breaks SPA behavior


9.3 CLIENT-SIDE SECURITY
-------------------------

Security considerations for the frontend application.

XSS PREVENTION:

React's Built-in Protection:
- Escapes all values by default
- {user.email} → Escaped output
- Prevents <script> injection
- Safe from most XSS attacks

Dangerous Patterns (NOT used in this codebase):
- dangerouslySetInnerHTML
- eval()
- innerHTML
- document.write()

Still Vulnerable:
- href="javascript:..." (not used)
- User-controlled URLs (if any)
- SVG injection (if rendering user SVG)

CSRF PROTECTION:

JWT Token Approach:
- Token stored in localStorage (not cookie)
- Not sent automatically
- Must be explicitly added to requests
- Immune to CSRF

Future with Cookies:
- Use SameSite=Strict or Lax
- Add CSRF token to forms
- Verify token on backend

AUTHENTICATION SECURITY:

Token Storage:
- localStorage (current)
- Accessible to JavaScript
- Vulnerable to XSS
- Persists across sessions

Better Approach:
- httpOnly cookies (if backend supports)
- Not accessible to JavaScript
- Requires secure HTTPS
- Automatic sending with requests

Token Validation:
- Currently no validation on load
- Should check expiration
- Should refresh before expiry
- Should handle invalid tokens

PASSWORD SECURITY:

Never Stored in State:
- Password cleared after submission
- Not persisted anywhere
- Only sent to server (over HTTPS hopefully)

Password Fields:
- type="password" (hidden dots)
- autoComplete="new-password" (browser suggests strong password)
- No value persistence

HTTPS REQUIREMENT:

Critical for:
- Preventing man-in-the-middle attacks
- Protecting token in transit
- Protecting password in transit
- localStorage security

Current:
- Development: http://localhost (acceptable)
- Production: MUST use HTTPS

CORS POLICY:

Backend CORS configuration allows all origins (*):
- Development convenience
- Production SHOULD restrict to specific domain
- Prevents unauthorized API access

CONTENT SECURITY POLICY:

Not implemented:
- No CSP headers
- Should add in production
- Restricts script sources
- Prevents inline scripts
- Mitigates XSS impact

Example CSP:
Content-Security-Policy: default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'

DEPENDENCY SECURITY:

Keep dependencies updated:
- npm audit: Check for vulnerabilities
- Dependabot: Automated updates
- Lock file: Ensures consistent versions

Current dependencies are recent (good):
- React 19.1.1 (latest)
- Vite 7.1.7 (latest)
- TypeScript 5.9.3 (latest)

INPUT SANITIZATION:

Not needed with React:
- React escapes by default
- No dangerouslySetInnerHTML
- No user HTML rendering

Exception:
- File uploads: Validate file type
- Currently only checks MIME type
- Should also check file content (backend)

SENSITIVE DATA:

Don't log sensitive data:
- Password never logged
- Token should not be logged
- User data logged only in development

Current:
console.log("Registration successful:", data);
- Acceptable in development
- Should remove for production

ERROR MESSAGES:

Don't leak information:
- "Invalid email or password" (good)
- NOT "Email doesn't exist"
- NOT "Password is incorrect"
- Prevents user enumeration

RATE LIMITING:

Not implemented client-side:
- Should be implemented on backend
- Prevents brute force attacks
- Limits failed login attempts

Client-side:
- Could disable button after N attempts
- Could show CAPTCHA
- Not a security measure (just UX)

SECURE CODING PRACTICES:

1. Trust Nothing:
   - Validate all backend responses
   - Check response.ok before parsing
   - Handle all error cases

2. Fail Securely:
   - Log out on auth errors
   - Clear sensitive state on errors
   - Don't expose error details

3. Least Privilege:
   - Only request needed data
   - Store minimal user info
   - Clear data when no longer needed

4. Defense in Depth:
   - Multiple layers of security
   - Client validation + Server validation
   - XSS protection + CSP + HTTPS

================================================================================
10. STYLING SYSTEM
================================================================================

10.1 CSS ARCHITECTURE
----------------------

The application uses vanilla CSS with a design system approach.

GLOBAL STYLES (index.css):
- CSS custom properties (variables)
- Base element styles
- Utility classes
- Responsive design
- Dark mode support

COMPONENT STYLES (App.css):
- App-specific overrides
- Legacy card class
- Minimal additional styles

NO CSS FRAMEWORKS:
- No Bootstrap, Tailwind, Material-UI
- Full control over styling
- Smaller bundle size
- Learning curve: CSS fundamentals

CSS ARCHITECTURE PATTERN:

1. :root → Design tokens (colors, shadows)
2. Element selectors → Base styles (body, button, input)
3. Class selectors → Components (.auth-card, .form-field)
4. Utility classes → Helpers (.muted, .error)
5. Media queries → Responsive and dark mode

BEM-like Naming:
- Block: .auth-card
- Element: .auth-header, .auth-footer
- Modifier: .btn.primary

No deep nesting:
- Flat selectors (good specificity)
- Easy to override
- No CSS preprocessor needed


10.2 DESIGN TOKENS
------------------

CSS Custom Properties (CSS Variables) for consistent theming.

COLOR PALETTE:

Primary Colors:
--color-bg: #ffffff             /* Page background */
--color-surface: #ffffff         /* Card/component surface */
--color-text: #0b2540            /* Text color (deep slate) */

Brand Colors:
--cerulean-600: #001bb7          /* Primary blue (buttons, links) */
--cerulean-700: #000f86          /* Darker blue (hover states) */
--cerulean-100: #e6eaff          /* Light blue (backgrounds) */

Accent Colors:
--accent: #ff8040                /* Orange accent (CTAs, highlights) */
--danger: #c92a2a                /* Red for errors, warnings */

Effects:
--shadow: 0 6px 18px rgba(3, 36, 56, 0.08)  /* Subtle card shadow */

USAGE:

color: var(--color-text);
background: var(--cerulean-600);
box-shadow: var(--shadow);

Benefits:
- Single source of truth
- Easy theme changes
- Runtime updates (JavaScript can modify)
- Inheritable (cascade down DOM)

DESIGN SYSTEM:

Typography Scale:
- Base font: system-ui, Avenir, Helvetica, Arial, sans-serif
- Line height: 1.5 (readable)
- Body text: 1rem (16px)
- Headings: 3.2em, 1.5rem
- Small text: 0.95rem, 0.9rem

Spacing Scale:
- Implicit (not variables)
- Small: 0.375rem (6px)
- Medium: 0.75rem (12px)
- Large: 1rem (16px)
- XL: 1.5rem (24px)
- XXL: 2rem (32px)

Border Radius:
- Inputs: 8px (subtle)
- Buttons: 10px (rounded)
- Cards: 14px (soft)

Border Width:
- Inputs: 1px
- Focus: 4px (outline/shadow)


10.3 DARK MODE SUPPORT
-----------------------

Automatic dark mode based on system preference.

DETECTION:

@media (prefers-color-scheme: dark) {
  /* Dark mode styles */
}

- Browser detects OS setting
- No JavaScript needed
- Instant switching
- Respects user preference

DARK MODE COLORS:

--color-bg: #041028              /* Deep navy background */
--color-surface: #071230         /* Card surface (lighter navy) */
--color-text: #eaf4ff            /* Light text (near white) */
--cerulean-600: #001bb7          /* Same primary blue */
--cerulean-700: #2b43ff          /* Lighter blue (better contrast) */
--accent: #ff8040                /* Same orange */
--danger: #ff7b7b                /* Lighter red (better contrast) */
--shadow: 0 8px 26px rgba(0, 11, 25, 0.6)  /* Deeper shadow */

CARD STYLING (dark mode):

.auth-card {
  background: linear-gradient(
    180deg,
    rgba(255, 255, 255, 0.02),
    rgba(255, 255, 255, 0.01)
  );
  border: 1px solid rgba(255, 255, 255, 0.04);
}

Technique:
- Subtle gradient overlay
- Semi-transparent border
- Creates depth without solid colors
- Modern glassmorphism effect

INPUT STYLING (dark mode):

input {
  background: rgba(255, 255, 255, 0.02);
  color: var(--color-text);
  border: 1px solid rgba(255, 255, 255, 0.06);
}

Features:
- Nearly transparent background
- Visible border
- Light text
- Good contrast

BUTTON STYLING (dark mode):

.btn.primary {
  box-shadow: 0 6px 24px rgba(0, 27, 183, 0.28);
}

- Stronger shadow (more prominent)
- Blue glow effect
- Stands out on dark background

CONTRAST RATIOS:

WCAG AA Compliance:
- Text: 4.5:1 ratio (normal text)
- Large text: 3:1 ratio (18pt+)
- UI components: 3:1 ratio

Dark mode adjustments:
- Lighter hover colors (better contrast)
- Stronger shadows (depth perception)
- Semi-transparent overlays (reduced glare)

TESTING DARK MODE:

Browser DevTools:
1. Open DevTools (F12)
2. Command Palette (Cmd+Shift+P or Ctrl+Shift+P)
3. Type "Rendering"
4. Toggle "Emulate CSS media feature prefers-color-scheme"

OS Level:
- macOS: System Preferences → General → Appearance
- Windows: Settings → Personalization → Colors
- Linux: Depends on desktop environment

JAVASCRIPT DETECTION (if needed):

const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches;

// Listen for changes
window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
  const isDark = e.matches;
  // Update UI
});

Not currently used (CSS-only solution sufficient).

FUTURE ENHANCEMENTS:

1. Manual Toggle:
   - Let user override system preference
   - Store in localStorage
   - JavaScript to apply class to <body>

2. High Contrast Mode:
   - For accessibility
   - Stronger colors
   - Thicker borders

3. Custom Themes:
   - Multiple color schemes
   - User preference storage
   - Theme picker UI


10.4 RESPONSIVE DESIGN
----------------------

Mobile-first responsive layout.

VIEWPORT META TAG (index.html):

<meta name="viewport" content="width=device-width, initial-scale=1.0" />

Purpose:
- Responsive on mobile devices
- Prevents zooming out to desktop view
- 1:1 pixel ratio

CONTAINER SIZING:

.app-container {
  width: 100%;
  max-width: 520px;
  padding: 2rem;
}

Strategy:
- 100% width (fills screen on mobile)
- max-width limits on desktop
- Padding prevents edge-to-edge

Result:
- Mobile: Full width with padding
- Tablet: Centered with max-width
- Desktop: Centered with max-width

CARD SIZING:

.auth-card {
  padding: 2rem;
  border-radius: 14px;
}

- Fixed padding (consistent spacing)
- No width constraint (inherits from container)
- Responsive border-radius (scales with rem)

CENTERING:

body {
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 100vh;
}

Technique:
- Flexbox for centering
- Horizontal: justify-content
- Vertical: align-items
- min-height: 100vh ensures full viewport

FORM INPUTS:

input {
  width: 100%;  /* Implicitly from parent */
  padding: 0.75rem 0.85rem;
  font-size: 1rem;
}

- Full width (parent controls size)
- Relative padding (scales with font size)
- Base font size (no zooming on mobile)

BUTTON SIZING:

button {
  padding: 0.75em 1.25em;
  font-size: 1rem;
}

- em units (scales with font size)
- Comfortable tap target (>= 44x44px)
- Consistent across devices

BREAKPOINTS:

Currently none!
- Single-column layout always
- Works on all screen sizes
- Simple, no media queries needed

Future breakpoints (if needed):
- Mobile: < 640px (default)
- Tablet: >= 640px (two columns?)
- Desktop: >= 1024px (sidebar?)

ACCESSIBILITY:

Touch Targets:
- Buttons >= 44x44px (Apple guidelines)
- Adequate spacing between clickable elements
- No overlapping hit areas

Font Scaling:
- rem units (respects user font size preference)
- Relative sizing (not fixed px)
- Zoom works correctly (no horizontal scroll)

Focus States:
- Keyboard navigation supported
- Visible focus indicators
- Tab order logical

MOBILE CONSIDERATIONS:

1. File Input:
   - Triggers native file picker
   - Camera option on mobile
   - Photo library access

2. Email Input:
   - type="email" shows email keyboard
   - @ key readily available
   - Autocomplete supported

3. Password Input:
   - Eye icon to show/hide (browser built-in)
   - Paste allowed (good security practice)
   - Password manager integration

4. Form Submission:
   - Enter key submits form
   - Button loading states
   - Prevents accidental double-submit

PERFORMANCE:

Minimal CSS:
- No framework overhead
- Small CSS bundle
- Fast parse and render

No Images (except logos):
- CSS gradients and shadows
- Fast loading
- Scalable (no resolution issues)

System Fonts:
- No web font loading
- Instant text render
- Native appearance

================================================================================
11. TYPESCRIPT CONFIGURATION
================================================================================

TypeScript setup for type-safe development.

TSCONFIG.JSON (root):
----------------------

{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}

Project References:
- Splits TypeScript configuration
- app: Application code (src/)
- node: Build tooling (vite.config.ts)
- Faster compilation (parallel processing)

TSCONFIG.APP.JSON (application):
---------------------------------

{
  "compilerOptions": {
    "target": "ES2022",                    // Modern JavaScript
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",                    // Latest module system
    "jsx": "react-jsx",                    // React 17+ JSX transform

    /* Bundler mode */
    "moduleResolution": "bundler",         // Vite-specific
    "allowImportingTsExtensions": true,    // Import .tsx files
    "noEmit": true,                        // No JS output (Vite handles)

    /* Strict type checking */
    "strict": true,                        // Enable all strict checks
    "noUnusedLocals": true,                // Error on unused variables
    "noUnusedParameters": true,            // Error on unused params
    "noFallthroughCasesInSwitch": true,   // Error on missing break
  },
  "include": ["src"]
}

KEY SETTINGS:

Target: ES2022
- Modern browser features
- Async/await, optional chaining, nullish coalescing
- Top-level await
- Class fields

Module: ESNext
- Latest import/export syntax
- Dynamic imports
- Tree-shaking support

JSX: react-jsx
- React 17+ automatic runtime
- No need to import React in every file
- Smaller bundle size

Module Resolution: bundler
- Vite-specific resolution
- Supports importing .tsx directly
- No need for .js extensions

No Emit: true
- TypeScript only checks types
- Vite handles transpilation
- Faster type checking

Strict Mode:
- strictNullChecks: null/undefined safety
- strictFunctionTypes: Function parameter checking
- strictBindCallApply: Correct bind/call/apply types
- alwaysStrict: "use strict" in output
- noImplicitAny: Must type unknowns
- noImplicitThis: this must be typed

TSCONFIG.NODE.JSON (build tools):
----------------------------------

For vite.config.ts and other build scripts:
- target: Latest Node.js features
- module: CommonJS or ESNext
- Different from app config

TYPE DEFINITIONS:

Package types:
- @types/react: React type definitions
- @types/react-dom: ReactDOM type definitions
- @types/node: Node.js type definitions

Installed automatically:
- TypeScript resolves from node_modules/@types
- No import needed
- Global types available everywhere

CUSTOM TYPES (src/types/):
--------------------------

Organized by domain:
- auth.types.ts: Authentication types
- Future: poll.types.ts, vote.types.ts, etc.

Benefits:
- Reusable across components
- Single source of truth
- Easy refactoring
- Better IDE autocomplete

TYPE SAFETY BENEFITS:

1. Compile-Time Errors:
   - Catch bugs before runtime
   - Invalid prop types
   - Missing required fields

2. IDE Support:
   - Autocomplete
   - Inline documentation
   - Refactoring tools

3. Self-Documenting:
   - Types show expected data
   - No need to read implementation
   - Clear contracts

4. Refactoring Safety:
   - Rename with confidence
   - Find all usages
   - Update interfaces globally

TYPE EXAMPLES:

Component Props:
  function Login({ onSuccess }: { onSuccess: () => void }) {
    // ...
  }

State Types:
  const [user, setUser] = useState<User | null>(null);

Event Handlers:
  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setEmail(e.target.value);
  };

Async Functions:
  const login = async (email: string, password: string): Promise<void> => {
    // ...
  };

API Responses:
  interface LoginResponse {
    access_token: string;
    token_type: string;
  }

STRICT NULL CHECKS:

Enabled by "strict": true

Forces handling null/undefined:
  const user: User | null = getUser();

  // Error: user might be null
  console.log(user.email);

  // Correct: Check first
  if (user) {
    console.log(user.email);
  }

  // Or: Optional chaining
  console.log(user?.email);

Benefits:
- Prevents null reference errors
- Explicit null handling
- Safer code

TYPE INFERENCE:

TypeScript infers types when possible:
  const [email, setEmail] = useState("");
  // email: string (inferred)

  const users: User[] = [];
  // TypeScript knows users is User[]

When to annotate:
- Function parameters (always)
- Complex return types
- When inference is wrong
- For clarity (even if inferred)

TYPE GUARDS:

Custom type checking:
  function isError(obj: any): obj is Error {
    return obj instanceof Error;
  }

  try {
    // ...
  } catch (err) {
    if (isError(err)) {
      console.log(err.message);  // TypeScript knows err is Error
    }
  }

Used in error handling throughout app.

================================================================================
12. BUILD & DEVELOPMENT
================================================================================

PACKAGE SCRIPTS (package.json):
--------------------------------

"dev": "vite"
- Starts development server
- Port: 5173
- Hot Module Replacement (HMR)
- Fast refresh (preserves state)

"build": "tsc -b && vite build"
- Type checking: tsc -b (build mode)
- Production build: vite build
- Output: dist/ folder
- Minified, optimized, bundled

"lint": "eslint ."
- Runs ESLint on all files
- Checks code quality
- Catches common errors

"preview": "vite preview"
- Preview production build locally
- Tests build before deployment
- Same as production (but local)

DEVELOPMENT SERVER:
-------------------

Vite Dev Server (vite.config.ts):

export default defineConfig({
  plugins: [react()],
  server: {
    host: '0.0.0.0',       // Listen on all interfaces
    port: 5173,            // Default Vite port
    watch: {
      usePolling: true,    // For Docker containers
    }
  }
})

Host: 0.0.0.0
- Accessible from other devices
- Important for Docker
- Default: localhost (127.0.0.1)

Port: 5173
- Vite default
- Can be changed
- Proxy can redirect

Watch: usePolling
- For Docker/VM file systems
- Slower but more reliable
- Native file watching doesn't work in containers

HOT MODULE REPLACEMENT (HMR):

Fast Refresh:
- Updates components without full reload
- Preserves React state
- Instant feedback
- Powered by Vite + React plugin

What triggers HMR:
- Component file changes
- CSS file changes
- Context/Hook changes

What causes full reload:
- main.tsx changes
- New dependencies added
- Configuration changes

PRODUCTION BUILD:
-----------------

Build Process:
1. tsc -b: Type check (fails build if errors)
2. vite build: Bundle and optimize
3. Output: dist/ folder

Optimizations:
- Minification (smaller files)
- Tree-shaking (remove unused code)
- Code splitting (lazy loading)
- Asset optimization (images, fonts)
- CSS extraction (separate file)

Build Output:
dist/
├── index.html           # Entry HTML (with script tags)
├── assets/
│   ├── index-[hash].js  # Main JS bundle
│   ├── index-[hash].css # Extracted CSS
│   └── [asset]-[hash]   # Other assets

Hash:
- Content-based hash in filename
- Cache busting (new hash = new file)
- Long cache headers (1 year)

BUNDLE ANALYSIS:

Visualize bundle:
npm run build -- --mode analyze

Rollup plugin:
- Shows bundle composition
- Identifies large dependencies
- Helps optimize bundle size

ENVIRONMENT VARIABLES:
----------------------

Vite Environment Variables:

.env file:
VITE_API_URL=http://localhost:8000

Usage:
const apiUrl = import.meta.env.VITE_API_URL;

Rules:
- Must start with VITE_ (exposed to client)
- import.meta.env (not process.env)
- Replaced at build time (not runtime)

Environment Files:
.env                    # All environments
.env.local              # Local overrides (gitignored)
.env.development        # Development only
.env.production         # Production only

Loading Order (highest priority first):
1. .env.[mode].local
2. .env.[mode]
3. .env.local
4. .env

Built-in Variables:
import.meta.env.MODE         // 'development' or 'production'
import.meta.env.DEV          // boolean
import.meta.env.PROD         // boolean
import.meta.env.BASE_URL     // base URL

DEPLOYMENT:
-----------

Static Hosting:

Build command: npm run build
Output directory: dist
Single-page app: Yes (needs rewrite rules)

Rewrite Rules:
- All routes → index.html
- Let React Router handle routing
- Avoid 404 on direct URL access

Netlify:
- Automatic builds from Git
- _redirects file: /* /index.html 200
- Environment variables in UI

Vercel:
- Zero-config for Vite
- Automatic redirects
- Environment variables in UI

GitHub Pages:
- Build and push dist/ to gh-pages branch
- Set base URL in vite.config.ts
- CNAME for custom domain

Docker:

Dockerfile:
FROM node:20-alpine AS build
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

FROM nginx:alpine
COPY --from=build /app/dist /usr/share/nginx/html
COPY nginx.conf /etc/nginx/conf.d/default.conf
EXPOSE 80

Multi-stage build:
- Stage 1: Build app
- Stage 2: Serve with nginx
- Smaller final image

Nginx Config:
server {
  listen 80;
  location / {
    root /usr/share/nginx/html;
    try_files $uri $uri/ /index.html;
  }
}

LINTING & FORMATTING:
---------------------

ESLint (eslint.config.js):
- Code quality rules
- React-specific rules
- TypeScript rules
- Auto-fix on save (IDE)

Prettier (if added):
- Code formatting
- Consistent style
- Auto-format on save

Pre-commit Hooks (if added):
- Run lint before commit
- Run type check
- Prevent bad code from entering repo

TESTING:
--------

Currently no tests!

Recommended:
- Vitest: Unit tests (Vite-native)
- React Testing Library: Component tests
- Playwright: E2E tests

Example setup:
npm install -D vitest @testing-library/react @testing-library/jest-dom

================================================================================
13. STATE MANAGEMENT PATTERNS
================================================================================

COMPONENT STATE (useState):
---------------------------

Local state within components:
const [email, setEmail] = useState("");

When to use:
- UI state (input values, loading, errors)
- Component-specific state
- No need to share with other components

Examples:
- Form inputs
- Modal open/closed
- Accordion expanded/collapsed

CONTEXT API (AuthContext):
--------------------------

Global state shared across components:
const { user, isAuthenticated, login } = useAuth();

When to use:
- App-wide state (authentication, theme)
- Deep prop drilling alternative
- State needed by many components

Examples:
- User authentication
- Theme preference
- Language selection

DERIVED STATE:
--------------

Computed from other state:
const isAuthenticated = !!token && !!user;
const canSubmit = email && passwordIsValid && passwordsMatch;

When to use:
- Value computed from other state
- No need to store separately
- Automatically updates when dependencies change

Benefits:
- Single source of truth
- No synchronization needed
- Always up-to-date

CONTROLLED COMPONENTS:
----------------------

React controls input value:
<input value={email} onChange={(e) => setEmail(e.target.value)} />

Benefits:
- React state is source of truth
- Can validate on every change
- Can transform input

Alternative (uncontrolled):
<input ref={inputRef} />
const value = inputRef.current.value;

Use controlled for forms (more React-like).

LIFTING STATE UP:
-----------------

Share state between siblings by moving to parent:

Before (can't share):
function ComponentA() {
  const [count, setCount] = useState(0);
}
function ComponentB() {
  const [count, setCount] = useState(0);
}

After (shared):
function Parent() {
  const [count, setCount] = useState(0);
  return (
    <>
      <ComponentA count={count} setCount={setCount} />
      <ComponentB count={count} setCount={setCount} />
    </>
  );
}

Not used in current app (Context handles sharing).

STATE UPDATES:
--------------

Batching:
React batches multiple setState calls:
setEmail("new@example.com");
setPassword("newpass");
setError("");
// Only one re-render

Async:
setState is asynchronous:
setCount(count + 1);
console.log(count);  // Still old value

Use callback form for sequential updates:
setCount(prevCount => prevCount + 1);

STATE INITIALIZATION:
---------------------

Expensive initialization:
const [state, setState] = useState(() => {
  return expensiveComputation();
});

Lazy initialization:
- Function only called once
- Not on every render
- Good for localStorage reads

Example:
const [token, setToken] = useState(() => {
  return localStorage.getItem("auth_token");
});

FUTURE: REDUCER PATTERN:
------------------------

For complex state logic:
const [state, dispatch] = useReducer(reducer, initialState);

When to use:
- Multiple related state values
- Complex state transitions
- Next state depends on previous

Example:
type Action =
  | { type: 'LOGIN_START' }
  | { type: 'LOGIN_SUCCESS', payload: User }
  | { type: 'LOGIN_FAILURE', error: string };

function authReducer(state: AuthState, action: Action) {
  switch (action.type) {
    case 'LOGIN_START':
      return { ...state, isLoading: true, error: null };
    case 'LOGIN_SUCCESS':
      return { ...state, isLoading: false, user: action.payload };
    case 'LOGIN_FAILURE':
      return { ...state, isLoading: false, error: action.error };
  }
}

Not needed for current app (simple state).

FUTURE: EXTERNAL STATE:
-----------------------

Libraries for advanced state management:
- Zustand: Simple global state
- Jotai: Atomic state
- Redux Toolkit: Complex apps
- TanStack Query: Server state

When needed:
- Large app with complex state
- Many shared state values
- Performance optimization needed
- Server state caching

Current app: Context API sufficient.

================================================================================
14. DATA FLOW DIAGRAM
================================================================================

USER LOGIN FLOW:
----------------

1. User enters email and password in Login component
   ↓
2. User clicks "Sign in" button
   ↓
3. Login component calls handleSubmit
   ↓
4. handleSubmit calls login() from useAuth hook
   ↓
5. AuthProvider login() sends POST to /login endpoint
   ↓
6. Backend validates credentials
   ↓
7. Backend returns JWT token
   ↓
8. AuthProvider decodes token
   ↓
9. AuthProvider stores token in localStorage
   ↓
10. AuthProvider updates state (token, user)
   ↓
11. Context update triggers re-render
   ↓
12. Login component navigates to home
   ↓
13. Home component reads isAuthenticated from context
   ↓
14. Home component shows admin dashboard

COMPONENT HIERARCHY:
--------------------

main.tsx
└── StrictMode
    └── BrowserRouter
        └── AuthProvider (manages auth state)
            └── App (routing)
                ├── Route path="/"
                │   └── Home (conditional UI)
                │       ├── If not authenticated:
                │       │   └── Login button
                │       └── If authenticated:
                │           ├── CSV upload
                │           ├── Verification sender
                │           └── Logout button
                │
                ├── Route path="/login"
                │   └── Login
                │       ├── Email input (useState)
                │       ├── Password input (useState)
                │       ├── Submit button
                │       └── Navigation links
                │
                └── Route path="/register"
                    └── Register
                        ├── Email input (useState)
                        ├── Password input (useState)
                        ├── Confirm password input (useState)
                        ├── Real-time validation
                        ├── Submit button
                        └── Navigation links

CONTEXT FLOW:
-------------

AuthProvider (provider)
  ↓ provides
AuthContext (context object)
  ↓ consumed by
useAuth (custom hook)
  ↓ used in
Components (Home, Login, Register)

DATA FLOW:
----------

User Action → Component Handler → Context Action → API Call → State Update → Re-render

Example:
Click "Sign in"
  → handleSubmit()
    → login(email, password)
      → fetch("/login", {...})
        → setToken(token), setUser(user)
          → isAuthenticated = true
            → Home shows admin UI

AUTHENTICATION STATE:
---------------------

State Shape:
{
  token: string | null,
  user: User | null,
  isLoading: boolean,
  isAuthenticated: boolean (computed)
}

State Transitions:
Initial: { token: null, user: null, isLoading: true, isAuthenticated: false }
  ↓ (localStorage check)
Token Found: { token: "...", user: null, isLoading: false, isAuthenticated: false }
  ↓ (should fetch user)
Login: { token: "...", user: {...}, isLoading: false, isAuthenticated: true }
Logout: { token: null, user: null, isLoading: false, isAuthenticated: false }

================================================================================
15. FUTURE ENHANCEMENTS
================================================================================

AUTHENTICATION:
1. Token refresh mechanism
2. Remember me checkbox (longer expiration)
3. Email verification page (/verify?token=...)
4. Password reset flow
5. Two-factor authentication
6. Social login (Google, GitHub)

USER EXPERIENCE:
1. Toast notifications (replace alerts)
2. Loading skeletons (better than spinners)
3. Optimistic updates (immediate feedback)
4. Undo actions
5. Keyboard shortcuts
6. Breadcrumb navigation

FEATURES:
1. Poll creation and management
2. Voting interface
3. Poll results visualization
4. User profile page
5. Admin dashboard with analytics
6. Email template customization
7. Bulk voter management
8. Export results (CSV, PDF)

PERFORMANCE:
1. Code splitting (lazy load routes)
2. Image optimization
3. Service worker (offline support)
4. Request caching
5. Debounce search inputs
6. Virtual scrolling for long lists

ACCESSIBILITY:
1. Skip navigation link
2. Keyboard shortcuts documentation
3. High contrast mode
4. Reduced motion support
5. Screen reader testing
6. Focus management on route change

TESTING:
1. Unit tests (Vitest)
2. Component tests (Testing Library)
3. E2E tests (Playwright)
4. Visual regression tests
5. Accessibility tests
6. Performance tests

DEVELOPER EXPERIENCE:
1. Storybook for components
2. API mocking (MSW)
3. Error boundary components
4. Development tools panel
5. Better TypeScript types
6. JSDoc comments

SECURITY:
1. Content Security Policy
2. HTTPS enforcement
3. Rate limiting (client-side feedback)
4. XSS protection audit
5. Dependency vulnerability scanning
6. Security headers

INFRASTRUCTURE:
1. CI/CD pipeline
2. Automated deployments
3. Environment management
4. Error monitoring (Sentry)
5. Analytics (privacy-respecting)
6. Performance monitoring

REFACTORING:
1. Use BackendService for all API calls
2. Extract reusable components
3. Consistent error handling
4. Form validation library
5. Centralized constants
6. Better folder structure

================================================================================
END OF DOCUMENTATION
================================================================================

This comprehensive documentation covers the entire E-Vote frontend architecture,
including React components, TypeScript configuration, authentication flow,
styling system, API communication, and future enhancements.

For questions or clarifications, refer to the inline code comments or contact
the development team.

Generated: 2024-11-06
Version: 1.0
